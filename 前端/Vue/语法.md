Vue命令
vue create name  #创建一个项目
vue init webpack projectName   #创建一个项目
vue ui  #以图像化的方式管理项目
npm run serve  #运行项目
npm run dev   #启动测试服务器
npm run build   #生成打包文件，上线的目录

## Vue提供的方法
- Vue.use()
- Vue.set()
  接受三个参数（作用，修改那些不会触发视图更新的数据的修改）
  参数1：待更新的数据
  参数2：第几项
  参数3：需要修改的值
  ``

## 模版
```
export defult {
  // 为什么要用方法来返回一个data对象呢？
  // 组件可能被多个父组件调用，没有返回的话，会共用data数据，造成影响
  // 用方法返回的话，每个组件的数据是隔离的
  data() {
    name: '',
    care: {
      a: 0
    }
  },
  // 三种props的写法，建议第三种
  props: ['sex', 'name'],
  props: {
    sex: string,
    name: string
  },
  props: {
    sex: { type: String, defult: 'sex' }
  },
  computed: {
    a() { return false }
  },
  watch: {
    name(val, oldVal) {},
    // 深度监听一个对象
    care: {
      hander() {},
      deep: true
    }
    // 监听一个对象的某个属性
    'care.a'(val, oldVal) {}
  }
  // 生命周期
  beforeCreate() {
    // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用
    // ps：常用于初始化非响应式变量
  },
  created() {
    // 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见
    // ps：常用于简单的ajax请求，页面的初始化
  },
  beforeMount() {
    // 在挂载开始之前被调用：相关的 render 函数首次被调用
  },
  mounted() {
    // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
    // 该钩子在服务器端渲染期间不被调用
    // ps：常用于获取VNode信息和操作，ajax请求
  },
  beforeUpdate() {
    // 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
    // ps：适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
  },
  updated() {
    // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
    // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之
  },
  activated() {
    // keep-alive 组件激活时调用
  },
  deactivated() {
    // keep-alive 组件停用时调用
  },
  beforeDestroy() {
    // 实例销毁之前调用。在这一步，实例仍然完全可用
    // ps：常用于销毁定时器、解绑全局事件、销毁插件对象等操作
  },
  destroyed() {
    // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
    // errorCaptured
    // 当捕获一个来自子孙组件的错误时被调用
  },
  methods: {
    setName() {}
  },
  // 组件自定义的指令
  directives: {

  }，
  // 引入的组件
  components: {
    ComA: CompC,  // 重命名引入的组件，建议在import的时候做重命名
    ComB
  }
}
```

## 框架提供的指令
- v-text
  将变量的值添加到标签里，无论是什么都添加为字符串
  ```
  <span v-text="msg"></span>
  // 同 <span>{{msg}}</span>
  ```
- v-html
  将变量的值添加到标签里，如果字符串中包含标签，会按照标签来渲染
- v-for
  ```
  // 将每一项都是对象的数组，按照列表的方式输出
  <p v-for=''(item, index) in list'' :key=''index''>{{ item.XXX }} - {{ index }}</p>
  // 也可以进行对象的渲染
  <p v-for=''(value, key) in list'' :key=''key''>{{ value }}</p>
  ```
- v-on （缩写 @）
  绑定相应的事件
  <button v-on:click=''shijian''></button>
  <button v-on:click.stop=''shijian''></button>   //在后面添加修改器，如：阻止冒泡等
  ps：父组件监听子组件的事件触发。用自定义组件（第三章5-7，8分钟）
  自定义事件的名称不要写成驼峰模式




















propsData选项
propsData: {  //主要是方便测试
    msg: 'hello'
}

ps：组件的命名方式，全部小写。com-a， com-b......，在Vue2中可以不用小写
<p :is="asd"></p>  //动态的渲染该组件

各种选项（选项 / DOM）
el
提供一个在html中存在的Dom元素作为Vue实例的挂载目标
template
一个字符串模板作为 Vue 实例的标识
render
Vue 选项中的 render 函数若存在， Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数



各种选项（选项 / 其他）
name
允许组件模板递归地调用自身
指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息
delimiters
functional
函数式组件
model
inheritAttrs
comments

实例属性
vm.$data
Vue 实例代理了对其 data 对象属性的访问
vm.$props
Vue 实例代理了对其 props 对象属性的访问
vm.$el
Vue 实例使用的根 DOM 元素
vm.$options
vm.$parent
父实例，如果当前实例有的话
vm.$root
当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己
vm.$children
当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的
vm.$slots

vm.$scopedSlots
vm.$refs
vm.$isServer
当前 Vue 实例是否运行于服务器
vm.$attrs
vm.$listeners

实例方法
指令



v-bind（缩写 ：）
绑定元素的属性
<a v-bind:href="" :title="care"></a>
变量的类型为string，直接展现。为数组，为指定多个类名。为对象，根据对象属性的bool值来展现，键名为属性值，bool键值控制属性的展现
可以直接写属性的值
ps：标签的属性最好也是全部小写
<a class="asd"></a>
区别，绑定的属性后面的字符串会当作变量，而直接使用的就是字符串
v-if && v-else
控制元素的显隐性，会从文档流里是删除掉，dom树中删除
<a v-if="asd"></a>
<a v-else></a>   //当上面的元素不显示的时候，下面的元素就i显示
v-else-if
<div v-if="type === 'A'">A</div>
<div v-else-if="type === 'B'">B</div>
<div v-else>Not A/B/C</div>
v-show
控制元素的显隐性，只是隐藏，还存在文档流中
<a v-show="asd"></a>
v-model
数据的双向绑定
<input v-model="asd" type="text" />
还有单选和多选
v-slot
v-once
<my-component v-once :comment="msg"></my-component>
组件及其子孙组件只渲染一次，提高页面更新渲染速度

内置组件
<slot>no slot</slot>  
slot标签将子组件中间包含的标签插在slot标签中间，当没有要插入的标签的时候，显示slot标签里的默认值
<keep-alive></keep-alive>
将动态的组件写在这个标签之间，当组件切换的时候，会将前一个组件的内容缓存起来，再切换回来的时候，加快相应速度
<transition name=“v” mode=“in-out”></transition>
<style>
.v-enter-active    .v-leace-active   //过渡状态，transtion写在这两个里面
.v-enter    .v-leave     //开始和结尾状态
</style>
将需要添加过渡状态的标签放在这个标签里面
只有配合v-if  v-show  :is='XXX'  这三个才会有效果
mode控制多元素的过渡序列
ps：同时还有用js来控制过渡状态，js可以控制的属性多一些

特殊特性
key
<li v-for="item in items" :key="item.id"></li>
ref
ref 被用来给元素或子组件注册引用信息
is
<component v-bind:is="currentView"></component>
该组件名字跟随变量的改变而改变
is接受一个注册了的组件名字，也接受一个导入的组件 如() => import('A')


在响应式的数据中，修改不会触发视图更新的有哪些
引用型数据的直接赋值，不会触发视图更新。
使用Vue.set() 方法来修改引用类型的数据
数组的处理函数push pop shift unshift reverse sort的使用会触发视图更新

vue页面切换的时候，上一个原组件会被销毁




- 


- 


- 


- 

watch: {
  'item.status'(val) {
    if (val === 3) {
      this.inputValue = '转换失败'  // 外面的渲染用 inputValue
    } else if {
      ......
    }
    .....
  }
}